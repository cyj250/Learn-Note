## 归并排序

**算法思想**

归并排序是基于归并操作的，是一种分治的思想，其需要将已经排好序的部分序列合并，时间复杂度为O(nlogn),需要申请额外的空间，空间复杂度为O(n).

**算法步骤**

1. 申请空间，使其大小为已经排好序的两个序列长度之和，用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排好序序列的初始位置
3. 比较两个指针元素的大小，合并入辅助空间中
4. 重复3步骤直到某一指针指到结尾处
5. 将另一序列直接合并到辅助空间中

![img](https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif)



**代码实现**

```c
void megert(int *arr,int leftPot,int rightPot,int rightBound){
    int i,j;
    int num = rightBound - leftPot + 1;
    int *tem = new int[num];
    int k = 0;
    i = leftPot;
    j = rightPot;
    while(i<=rightPot-1&&j<=rightBound){
        if(arr[i]<=arr[j]){
            tem[k++] = arr[i++];
        }
        else 
            tem[k++] = arr[j++];
    }
    while(i<=rightPot-1){
        tem[k++] = arr[i++];
    }
    while(j<=rightBound){
        tem[k++] = arr[j++];
    }
    for(int m=0;m<num;m++){//这一步不太好想
        arr[leftPot+m] = tem[m];
    }
}

void sort(int *arr,int left,int right){
    if(left==right) return;
    int mid = left + (right-left)/2;
    sort(arr,left,mid);
    sort(arr,mid+1,right);
    megert(arr,left,mid+1,right);
}
```

