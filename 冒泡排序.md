# 冒泡排序

**算法思想**

第一次遍历第一个到最后一个元素，两两比较，将较小或较大的值放到右边

之后重复此操作，遍历长度减小一

![img](https://img2018.cnblogs.com/blog/1441368/201903/1441368-20190303094717101-1607655792.png)

**算法实现**

```c
void bubbleSort(int *arr,int length){
    int i,j;
    for(i=length-1;i>=0;i--){
        for(j=0;j<i-1;j++){
            if(arr[j]>arr[j+1]){
                int tem = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tem;
            }
        }
    }
}
```

**算法分析**

时间复杂度：O(n^2)（平均和最坏）最好时间复杂度为O(n)

空间复杂度：O(1)

稳定性：稳定



**算法优化**

**方法一**

在外层循环中加入判断标志，在每一次循环过程中，判断元素位置是否发生交换，在最好的情况下，遍历一次即可，时间复杂度为O(n);

```c
void bubbleSort1(int *arr,int length){
    int i,j,flag;
    for(i=length-1;i>=0;i--){
        flag = 0;
        for(j=0;j<i;j++){
            if(arr[j]>arr[j+1]){
                flag = 1;
                int tem = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tem;
            }
        }
        if(flag==0) return;
    }
}
```

**方法二**

优化内层循环

记住最后一次交换的位置，则下一次循环时，[0,最后交换]为无序区，剩余的为有序区，下次循环只需在无序区进行。

```c
void bubbleSort2(int *arr,int length){
    int i,j;
    int lastExchange,k = length-1;
    for(i=length-1;i>=0;i--){
        int flag = 0;//每次循环将flag置为0，才能判断是否发生交换
        for(j=0;j<k;j++){
            if(arr[j]>arr[j+1]){
                int tem = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tem;
                lastExchange = j;
                flag = 1;
            }
        }
        k = lastExchange;
        if(flag==0) return;
    }
}
```

