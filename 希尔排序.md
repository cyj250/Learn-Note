## 希尔排序

**算法思想**

希尔排序是在插入排序的基础上，改变每次比较的间隔，最终再进行一次间隔为一的插入排序。

**算法分析**

希尔排序时间复杂度是 **O(n^(1.3-2))**，空间复杂度为常数阶 **O(1)**。希尔排序没有时间复杂度为 **O(n(logn))** 的快速排序算法快 ，因此对中等大小规模表现良好，但对规模非常大的数据排序不是最优选择，总之比一般 **O(n^2 )** 复杂度的算法快得多。

**代码实现**

```c
void ShellSort(int *arr,int length){
    int h=1,i,j;
    while(h<length/3){//Knuth序列，效率较高
        h = h*3+1;
    }
    for(h;h>=1;h = (h-1)/3){
        for(i=h;i<length;i++){//就是之后的所有数据都要进行比较，
            for(j=i;j>h-1;j--){
                if(arr[j]<arr[j-h])
                    swap(&arr[j],&arr[j-h]);
            }
        }
    }
}
void swap(int *a,int *b){
    int tem = *a;
    *a = *b;
    *b = tem;
}
```

### 过程图示

希尔排序目的为了加快速度改进了插入排序，交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。

在此我们选择增量 **gap=length/2**，缩小增量以 **gap = gap/2** 的方式，用序列 **{n/2,(n/2)/2...1}** 来表示。

如图示例：

（1）初始增量第一趟 **gap = length/2 = 4**

![img](https://www.runoob.com/wp-content/uploads/2020/09/ShellSort-01.png)

（2）第二趟，增量缩小为 2

![img](https://www.runoob.com/wp-content/uploads/2020/09/ShellSort-02.png)

3）第三趟，增量缩小为 1,得到最终排序结果

![img](https://www.runoob.com/wp-content/uploads/2020/09/ShellSort-03.png)