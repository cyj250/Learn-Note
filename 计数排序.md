## 计数排序

**算法思想**

计数排序适用于数据量较大而数据范围小的序列，其思想是首先统计每个数出现的次数，然后再次循环，将数据填入相应的位置。但是，为了实现计数排序的稳定性，需要将计数数组进行改造。同时数组下标要注意序号。其时间复杂度为O(n+k),空间复杂度为O(k).

**代码实现**

```c
int findMin(int *arr,int length){
    int i;
    int min = arr[0];
    for(i=0;i<length;i++){
        if(arr[i]<min) min = arr[i];
    }
    return min;
}
int findMax(int *arr,int length){
    int i;
    int max = arr[0];
    for(i=0;i<length;i++){
        if(arr[i]>max) max = arr[i];
    }
    return max;
}

void countSort(int *arr,int length,int *ans){
    int min = findMin(arr,length);
    int max = findMax(arr,length);
    int nums = max-min+1;
    int i;
    int *count = (int *)malloc(sizeof(int)*nums);
    for(i=0;i<nums;i++) count[i] = 0;
    for(i=0;i<length;i++) count[arr[i]-min]++;
    for(i=1;i<nums;i++)count[i] = count[i-1]+count[i];
    for(i=length-1;i>=0;i--){
        ans[--count[arr[i]-min]] = arr[i];//注意count的下标
    }
}
```

